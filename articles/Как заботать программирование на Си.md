Как ни странно, этот язык **не вращается в гробу у ВМК, как Паскаль**. Вполне жив, хоть и в основном на компактном рынке системного программирования (драйверы для джойстика или там модули ядра писать дяденьки за копейки).  Ещё он часто используется для последующего перехода на C++, чтобы запустить стартап, подписать контракт с IBM, **вырезать всех конкурентов**, и тупо **отдать все свое состояние** фонду.

**Все книжки в комментариях, там же делимся своим опытом и материалами.**

  

**Шаг 0.** 

Лучше ботать Сишку в её естественной среде обитания, которой является **UNIX** (на нем она и написана). Так как далеко не все версии никсов доступны и просты, ставим (сравнительно) несложный дистрибутив **Linux** (Ubuntu, Fedora, Mint, Debian, не Arch и не Gentoo).  Ко всему, эти системы распространяются под свободными лицензиями, поэтому можно получить бесплатно (это та самая халява, которую зовут физтехи перед НК). Вообще это профессиональный стандарт, причём не только для разработчиков.

1) Ставим Линукс, привыкаем к нему, любим его;

2) Читаем и практикуем по жизни всю книгу _А. В. Столярова_ (под боевым псевдонимом Столяр) по **UNIX** (кроме главы _"Инструментарий программиста"_). Можно вместо этого читать его же _"Программирование: введение в профессию", том 1_, но лишь главы 1.1-1.2. Автор хоть и неисправимый сторонник Паскаля на 1 курсе, но пособия годные, поэтому разобраться на уровне продвинутого пользователя в Линуксе можно;

3) Полезно пописать скриптики. Скорее всего, будет достаточно повседневного использования и заданий "_Командная строка Unix_" из задачника Столяра 

4) Освоить **Git** и **GitHub** (это разное!). Для начала хватит связать их по **SSH** и понять, что и как с **push, pull, add, commit, branch, checkout, merge...**

  

**Шаг 1.** 

Переходим непосредственно к языку и программированию.

1) Читаем книгу _Стивена Праты "Язык программирования C. Лекци и упражнения"_ **строго в 6 издании**. Делаем все упражнения (здесь очень пригодится **Git&GitHub**), разбираем все примеры (очень хорошие и современны). Книга именно по программированию, но на языке Си. То есть научитесь и языку, и прогать с нуля. Все объяснения чёткие и верные, а главное даже понятные. В этом и уникальность. 

Но за всё нужно платить: в ней **900+ страниц**. Ботая (читая и решая) в среднем по главе в три дня можно заботать всю книгу за полтора месяца в неспешном темпе.

2) Устройство компьютера и общие сведения из **Computer Science**. 

В данном случае вполне подойдут книги _Владстона Фило серии "Теоретический минимум по Computer Science"_ (сначала первая, зелёная, потом, возможно, остальные, пока их две). Также подойдут главы 1.3-1.4 из всё той же книги _Столяра_. Первые книги представляют из себя чуть-чуть теории с примерами на задачах, похожих на реальные. Последняя чуть-чуть перегружена математикой. Начинать читать их стоит не сильно раньше главы 11 в _Прате_;

3) Будет очень хорошей идеей научиться элементарной отладке программ с помощью **gdb, valgrind** и **address sanitizer**. Ещё лучше познакомиться с **GUN** **make** и **Doxygen**. Всё это понадобится как на **Си**, так и в "**Плюсах**"... И много где ещё.



**Шаг 2.** 

Теперь на дно, то есть глубоко в код. Можно начать сразу с этого шага, если **очень близкое знакомство** с программированием состоялось ранее.

1) Читаем _"Язык программирования C" Кернигана и Ритчи_, во втором издании (оно же "ANSI C"). 

Если читали _Прату_, то можно не сильно спешить с _K&R._ Авторы принимали участие в разработке и стандартизации языка, поэтому точнее и яснее описать язык не сможет никто. Читаем и делаем заинтересовавшие упражнения. Советую делать именно те, которые кажутся читателю прикладными и полезными;

2) Читаем книгу _Хэзфилда "Искусство программирования на C"_ и, быть может, _Роба и Кернигана "Практика программирования"._ 

В них рассмотрены основные моменты практической разработки. Никакого олимпиадного кода 5 задач в 5 часов. Даже ПТУшнику ясно, что на работе не будет необходимости соревноваться с коллегами. Обратите особое внимание на то, что **можно иногда пренебречь крохами в производительности в угоду читаемости и красоты кода**. Упражнения из книг решать стоит (или, возможно, дорабатывать примеры из текста). В остальном, где-то с середниы КР можно начать одну из них и радоваться жизни. Применять полезное из них повсеместно;

3) Найти подружку (или друга, **главное, чтобы пол не отвлекал и вас не абьюзили**) для совместного программирования. Используйте Гитхаб для совместной работы. Пишите действительно интересные и **похожие на полезные программы.** Примерами могут служить задачи и этюды из задачника _Столяра_, но только те, которые интересны. **Поработать на дядю ещё успеете: "вкладывайтесь в свое будущее" и живите в общаге с 4-мя дебилами (считая вас)**. Если же не терпится **стать лакеем капитала и продать свою душу за копейки**, то начинать можно при разборе книг Шага 2.

  

**Шаг...** 

Бежим! Когда основы (да, это были они) программирования заботаны и написано суммарно **не менее 2500-3000 "чистых"** (непустых, документация в счёт) строк хорошего кода на **Си** в больших проектах из **Шага 2** и из них есть хотя бы один на **700 строк и более**, можно применять свои знания и навыки для получения дальнейших знаний. 

**Зачем учить именно Си?** Это простой язык (причём очень простой и компактный), на основе которого можно понять, как именно надо программировать (документирование, декомпозиция кода, модульность и её преимущества, обработка ошибок, приёмы и инструменты отладки) на любом языке и как этот язык правильно заботать. Кроме того, далее он понадобится для изучения **ООП** и **АТД** на **C++**, операционных систем и компьютерных основ программирования с применением **языков ассемблера** и **Си**. 

Что касается применения самого языка, он используется в системном **(ОС**и и загрузчики для них, компиляторы, драйверы, демоны, вредоносы и защита от них, графика в играх и не только, базы данных) и сетевом (браузеры, расширения для них) программировании, разработке под микроконтроллеры и встраиваемые системы ("интернет вещей" и умные девайсы в том числе). Даже в "**Питончеге**", так любимом всеми школьниками, многие библиотеки написаны фактически на **C/C++**, некоторые даже с применением **ассемблера**.



**По примерам заданий для практики на языке Си** (кроме уже указанных):

**- Аналоги стандартных утилит Unix-систем.** 

Советую упрощённо реализовать **sort** (со своей сортировкой и компаратором строк) для близкого знакомства с указателями и памятью вообще. Можно также поставить дополнительные условия типа необходимости отсортировать "с конца", как бы рифмуя;

**- АТД** стек, список, дерево (и любой другой);

**- Стековый вычислитель** (по типу Forth-машины, можно с упрощениями) для использования написанного ранее стека и библиотеки работы со строками из первой задачи;

**- Аллокатор памяти из книги Игоря Жиркова**. Полезный пример с лёгким погружением в системное программирование и профсреду;

**- Вычислитель (или упроститель) выражений по символьной записи** (очень круто сделать её в формате LaTeX) для практики деревьев и использования своих же АТД. Очень крутой проект, его можно развить в том числе в самый настоящий компилятор;

**- Аналоги тетриса или змейки**. Или любой другой интересной игры (возможно, даже выдуманной лично). Удобно применять для этого библиотеку ncurses;

**- Свои простые инструменты для проверки стиля или корректности программы на Си или другом языке.** Возможно, на простейшем уровне. Подойдёт для практики строк и структур данных, АТД стек;

**- Инструмент для форматирования кода.** Для тех же целей, что и предыдущая.
